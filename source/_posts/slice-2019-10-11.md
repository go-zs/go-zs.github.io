---
title: golang系列(5)——slice切片
date: 2019-10-11 13:08:55
updated: 2019-10-11 13:08:55
tags:
- golang
categories:
- golang
---

golang的切片跟python的list一样几乎是用的最多的数据结构了，如果要用它真的很不容易。这篇文件是对工作中slice的使用和遇到坑的总结。

<!-- more -->

slice使用起来很像是一个会自动扩容的数组，通过源码可以看到它的本质。

```golang
// runtime/slice.go
type slice struct {
	array unsafe.Pointer // 指向数组的指针
	len   int            // 长度
	cap   int            // 数组容量
}
```

很明显，`slice`有3个属性，指针、长度、容量，也就是说实际的元素还是以数组的形式存储。



## append 扩容

slice作为变长的数组，它的扩容是怎么实现的呢。我们来看一下`slice append` 方法的源码。


```golang
// runtime/slice.go
// growslice handles slice growth during append.
func growslice(et *_type, old slice, cap int) slice {
    ...

    newcap := old.cap
	doublecap := newcap + newcap
	if cap > doublecap {
		newcap = cap
	} else {
        // 小于1024的时候，容量翻倍
		if old.len < 1024 {
			newcap = doublecap
		} else {
            // 大于1024，每次扩容1/4
			for 0 < newcap && newcap < cap {
				newcap += newcap / 4
			}
			if newcap <= 0 {
				newcap = cap
			}
		}
    }
    
    ...

    if overflow || capmem > maxAlloc {
        panic(errorString("growslice: cap out of range"))
	}

	var p unsafe.Pointer
	if et.ptrdata == 0 {
		p = mallocgc(capmem, nil, false)
		// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).
		// Only clear the part that will not be overwritten.
		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
	} else {
		// Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.
		p = mallocgc(capmem, et, true)
		if lenmem > 0 && writeBarrier.enabled {
			// Only shade the pointers in old.array since we know the destination slice p
			// only contains nil pointers because it has been cleared during alloc.
			bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem)
		}
	}
    memmove(p, old.array, lenmem)
    
    return slice{p, old.len, newcap}
}
```

从源码可以看出，1024字节以下，每次容量翻倍，1024字节以上，每次增加1/4，然后返回一个新的切片。也就是扩容需要重新生成一个新的底层数组，频繁的扩容必然会带来性能损耗。

## 创建Slice

golang提供了创建多种切片方式，需要注意的是通过切片操作创建的新`slice`与旧`slice`是共享底层数组的。

```
package main

import "fmt"

func main() {
	var s1 []int            // 直接声明
	s2 := []int{1, 2, 3}    // 赋值
	s3 := *new([]int)       // new
	s4 := make([]int, 3, 5) // make
	s5 := s4[:2]            // 切片
	fmt.Printf("s1: len = %d, cap = %d\n", len(s1), cap(s1))
	fmt.Printf("s2: len = %d, cap = %d\n", len(s2), cap(s2))
	fmt.Printf("s3: len = %d, cap = %d\n", len(s3), cap(s3))
	fmt.Printf("s4: len = %d, cap = %d\n", len(s4), cap(s4))
	fmt.Printf("s5: len = %d, cap = %d\n", len(s5), cap(s5))
    fmt.Println(s1 == nil)
	fmt.Println(s2 == nil)
    s5[0] = 15
	fmt.Println(s4)
	fmt.Println(s5)
}

// 输出
s1: len = 0, cap = 0
s2: len = 3, cap = 3
s3: len = 0, cap = 0
s4: len = 3, cap = 5
s5: len = 2, cap = 5
true
true
[15 0 0] // 因为s4,s5共享底层数组，s5改变之后，s4也被改变了
[15 0]
```

## 切片操作

slice并没有像`python list`提供那么多丰富的api，但是通过`append`方法可以实现很多常用的操作

元素插入

```golang
fvar a = []int{1,2,3}
a = append([]int{0}, a...)        // 在开头添加1个元素
a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片

a = append(a[:i], append([]int{x}, a[i:]...)...)     // 在第i个位置插入x
a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片
```

可以用copy和append组合可以避免创建中间的临时切片，同样是完成添加元素的操作：
```golang
a = append(a, 0)     // 切片扩展1个空间
copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置
a[i] = x             // 设置新添加的元素
```

删除元素
```golang
a = append(a[:0], a[1:]...) // 删除开头1个元素
a = append(a[:0], a[N:]...) // 删除开头N个元素
a = append(a[:i], a[i+1:]...) // 删除中间1个元素
a = append(a[:i], a[i+N:]...) // 删除中间N个元素
a = a[:len(a)-1]   // 删除尾部1个元素
a = a[:len(a)-N]   // 删除尾部N个元素
```

比如下面的TrimSpace函数用于删除[]byte中的空格。函数实现利用了0长切片的特性，实现高效而且简洁。

```golang
func TrimSpace(s []byte) []byte {
    b := s[:0]  // 利用 s 的底层数组，无需额外分配空间
    for _, x := range s {
        if x != ' ' {
            b = append(b, x)
        }
    }
    return b
}
```