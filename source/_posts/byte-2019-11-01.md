---
title: golang系列(6)——byte操作
date: 2019-11-01 14:57:54
tags:
---

[]byte和string 在 golang 里是非常重要的数据结构，虽然我们通常把它当成一个整体进行操作，实际上它在内存是一片连续的字符数组，并且golang里`string`是只读的。

<!-- more -->

## []byte与string
查看源码发现`string`底层结构与`slice`非常相似

```golang

type stringHeader struct {
	str unsafe.Pointer
	len int
}

```

`string`和`[]byte`互转

```golang
b := "abc"
c := []byte(b)
b = string(c)
```
当我们进行文件读写、json序列化等操作时候经常会用到`[]byte`和`string`的转换，当然类型转换的开销并没有想象的那么小，我们经常会看到 runtime.slicebytetostring 等函数出现在火焰图1中，成为程序的性能热点，源码如下。

```golang
// []byte to string
// Buf is a fixed-size buffer for the result,
// it is not nil if the result does not escape.
func slicebytetostring(buf *tmpBuf, b []byte) (str string) {
	l := len(b)
	if l == 0 {
		// Turns out to be a relatively common case.
		// Consider that you want to parse out data between parens in "foo()bar",
		// you find the indices and convert the subslice to string.
		return ""
	}
	if raceenabled {
		racereadrangepc(unsafe.Pointer(&b[0]),
			uintptr(l),
			getcallerpc(),
			funcPC(slicebytetostring))
	}
	if msanenabled {
		msanread(unsafe.Pointer(&b[0]), uintptr(l))
	}
	if l == 1 {
		stringStructOf(&str).str = unsafe.Pointer(&staticbytes[b[0]])
		stringStructOf(&str).len = 1
		return
	}

	var p unsafe.Pointer
	if buf != nil && len(b) <= len(buf) {
		p = unsafe.Pointer(buf)
	} else {
		p = mallocgc(uintptr(len(b)), nil, false)
	}
	stringStructOf(&str).str = p
	stringStructOf(&str).len = len(b)
	memmove(p, (*(*slice)(unsafe.Pointer(&b))).array, uintptr(len(b)))
	return
}

// string to []byte
func stringtoslicebyte(buf *tmpBuf, s string) []byte {
	var b []byte
	if buf != nil && len(s) <= len(buf) {
		*buf = tmpBuf{}
		b = buf[:len(s)]
	} else {
		b = rawbyteslice(len(s))
	}
	copy(b, s)
	return b
}

```

## byte和int互转

```
package main

import (
    "bytes"
    "encoding/binary"
    "fmt"
)

func IntToBytes(n int) []byte {
    data := int64(n)
    bytebuf := bytes.NewBuffer([]byte{})
    binary.Write(bytebuf, binary.BigEndian, data)
    return bytebuf.Bytes()
}

func BytesToInt(bys []byte) int {
    bytebuff := bytes.NewBuffer(bys)
    var data int64
    binary.Read(bytebuff, binary.BigEndian, &data)
    return int(data)
}
```