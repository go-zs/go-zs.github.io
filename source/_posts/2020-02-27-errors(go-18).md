---
title: golang系列(18)--errors包
date: 2020-02-27 10:12:38
tags:
- golang
categories:
- golang
---

golang错误处理一直以来争议都很大，`errors`包提供了很多功能大大增强了golang程序异常处理能力。

<!-- more -->

## New && Errorf

```golang
// New returns an error with the supplied message.
// New also records the stack trace at the point it was called.
func New(message string) error {
	return &fundamental{
		msg:   message,
		stack: callers(),
	}
}

// Errorf formats according to a format specifier and returns the string
// as a value that satisfies error.
// Errorf also records the stack trace at the point it was called.
func Errorf(format string, args ...interface{}) error {
	return &fundamental{
		msg:   fmt.Sprintf(format, args...),
		stack: callers(),
	}
}

// fundamental is an error that has a message and a stack, but no caller.
type fundamental struct {
	msg string
	*stack
}

func (f *fundamental) Error() string { return f.msg }

// %s,%v //功能一样，输出错误信息，不包含堆栈
// %q //输出的错误信息带引号，不包含堆栈
// %+v //输出错误信息和堆栈
func (f *fundamental) Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			io.WriteString(s, f.msg)
			f.stack.Format(s, verb)
			return
		}
		fallthrough
	case 's':
		io.WriteString(s, f.msg)
	case 'q':
		fmt.Fprintf(s, "%q", f.msg)
	}
}
```
`fundamental`实现了`Formatter`接口，可以通过`fmt.Printf`打印堆栈信息

```golang
package main

import (
	"fmt"
	"github.com/pkg/errors"
)

func TestErrorf(args []string) error {
	if len(args) < 3 {
		return errors.Errorf("not enough arguments, expected at least 3, got %d", len(args))
	}
	return nil
}

func main() {
    err := TestErrorf([]string{"1"})
    // +v flag
	fmt.Printf("%+v\n", err)
}

// output
not enough arguments, expected at least 3, got 1
main.TestErrorf
        /Users/zs/projects/golang/simple/e.go:10
main.main
        /Users/zs/projects/golang/simple/e.go:16
runtime.main
        /usr/local/go/src/runtime/proc.go:203
runtime.goexit
        /usr/local/go/src/runtime/asm_amd64.s:1357
```


## WithStack

```golang
// WithStack annotates err with a stack trace at the point WithStack was called.
// If err is nil, WithStack returns nil.
func WithStack(err error) error {
	if err == nil {
		return nil
	}
	return &withStack{
		err,
		callers(),
	}
}

type withStack struct {
	error
	*stack
}
```

## WithMessage

```golang
type withMessage struct {
	cause error
	msg   string
}

func WithMessage(err error, message string) error {
	if err == nil {
		return nil
	}
	return &withMessage{
		cause: err,
		msg:   message,
	}
}

func (w *withMessage) Error() string { return w.msg + ": " + w.cause.Error() }
func (w *withMessage) Cause() error  { return w.cause }

// Unwrap provides compatibility for Go 1.13 error chains.
func (w *withMessage) Unwrap() error { return w.cause }

func (w *withMessage) Format(s fmt.State, verb rune) {
	switch verb {
	case 'v':
		if s.Flag('+') {
			fmt.Fprintf(s, "%+v\n", w.Cause())
			io.WriteString(s, w.msg)
			return
		}
		fallthrough
	case 's', 'q':
		io.WriteString(s, w.Error())
	}
}
```

## Wrap

```golang
// Wrap returns an error annotating err with a stack trace
// at the point Wrap is called, and the supplied message.
// If err is nil, Wrap returns nil.
func Wrap(err error, message string) error {
	if err == nil {
		return nil
	}
	err = &withMessage{
		cause: err,
		msg:   message,
	}
	return &withStack{
		err,
		callers(),
	}
}
```

## 最佳实践

参考B站毛剑大佬2019年GopherChina上的演讲，总结的golang异常处理最佳实践

1. 库内代码使用`pkg/errors`的`New/Errorf`返回错误(保留堆栈信息)
2. 库内代码接受其它库的返回，直接透传(已经保留过了，直接返回)
3. 和标准库/第三方库的交互，用`WithStack/Wrap`来携带上下文(不破坏，可能会重复保留堆栈)
4. 把错误抛给调用者，而不是到处打日志
5. 在顶部调用者或work goroutine统一打日志


## errgroup

errgroup 在 WaitGroup 的基础上实现子协程错误传递, 同时使用 context 控制协程的生命周期。



```golang
package main

import (
    "context"
    "fmt"
    "time"

    "golang.org/x/sync/errgroup"
)

func main() {
    group, _ := errgroup.WithContext(context.Background())
    for i := 0; i < 5; i++ {
        index := i
        group.Go(func() error {
            fmt.Printf("start to execute the %d gorouting\n", index)
            time.Sleep(time.Duration(index) * time.Second)
            if index%2 == 0 {
                return fmt.Errorf("something has failed on grouting:%d", index)
            }
            fmt.Printf("gorouting:%d end\n", index)
            return nil
        })
    }
    if err := group.Wait(); err != nil {
        fmt.Println(err)
    }
}
```