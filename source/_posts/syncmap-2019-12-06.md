---
title: golang系列(10)——线程安全map
date: 2019-12-06 13:41:50
tags:
---

golang中goroutine中操作map是线程安全的吗？很明显不是的，并发操作会出现异常。


<!-- more -->


## 并发安全测试

我们写一个简单的demo程序，测试一下map并发安全性。

```golang
package main

import "fmt"

var (
	m = make(map[int]int)
)

func Read() {
	for {
		_ = m[1]
	}
}

func Write() {
	for {
		m[1] = 15
	}
}

func main() {
	m[1] = 5

	go Read()
	go Write()
	select {

	}
}

// 输出
// fatal error: concurrent map read and map write

// goroutine 5 [running]:
// runtime.throw(0x10d4b60, 0x21)
//         /usr/local/Cellar/go/1.13/libexec/src/runtime/panic.go:774 +0x72 fp=0xc000048758 sp=0xc000048728 pc=0x10296b2
// ...
```

很快程序就出现异常了。很明显map并发读写是不安全的。官方解释如下。

> After long discussion it was decided that the typical use of maps did not require safe access from multiple goroutines, and in those cases where it did, the map was probably part of some larger data structure or computation that was already synchronized. Therefore requiring that all map operations grab a mutex would slow down most programs and add safety to few. This was not an easy decision, however, since it means uncontrolled map access can crash the program.


这个异常是无法被recover的, 测试一下
```golang
package main

import "fmt"

var (
	m = make(map[int]int)
)

func Read() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("read error")
		}
	}()
	for {
		_ = m[1]
	}
}

func Write() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println("write error")
		}
	}()
	for {
		m[1] = 15
	}
}

func main() {
	m[1] = 5

	go Read()
	go Write()
	select {

	}
}
// 输出
// fatal error: concurrent map read and map write

// goroutine 5 [running]:
// runtime.throw(0x10d4b60, 0x21)
//         /usr/local/Cellar/go/1.13/libexec/src/runtime/panic.go:774 +0x72 fp=0xc000048758 sp=0xc000048728 pc=0x10296b2
```

从结果中我们可以看出`recover`函数未被执行。

## 并发安全实现

我们有两种方式可以解决这个问题

1. 加锁

```golang
package main

import (
	"fmt"
	"sync"
)
var m *SafeMap
var wg sync.WaitGroup

type SafeMap struct {
	M map[int]int
	sync.RWMutex
}

func NewSafeMap() *SafeMap {
	return &SafeMap{
		M:       make(map[int]int),
		RWMutex: sync.RWMutex{},
	}
}

func Read() {
	for i:=0; i < 100000; i++{
		m.RLock()
		m.M[1] = 15
		m.RUnlock()
	}
	fmt.Println("read done")
	wg.Done()
}

func Write() {
	for i:=0; i < 100000; i++{
		m.Lock()
		_ = m.M[1]
		m.Unlock()
	}
	fmt.Println("write done")
	wg.Done()
}


func main() {
	m = NewSafeMap()
	wg.Add(2)
	m.M[1] = 15
	go Read()
	go Write()
	wg.Wait()
}
// 输出
// write done
// read done
```

加锁实现很简单，当然性能上就不那么让人满意了。

2. golang1.9引入的sync.Map


因为想要借助 lock free 来提高访问效率，那么势必需要增加一些辅助的数据结构来支持 lock free 操作。
在 syncmap 中实际存在两个 map：read map & dirty map。 可以看一下代码中的表示:


```golang
type Map struct {
    mu sync.Mutex  // 锁
    read atomic.Value // readOnly，只读不用加锁
    // dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，
    // 但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),
    // 有些数据还可能没有移动到read字段中。
    dirty map[interface{}]*entry  // 操作需要加锁
    // 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，
	// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁。
    misses int 
}

type readOnly struct {
    m       map[interface{}]*entry
    amended bool // true if the dirty map contains some key not in m.
}

// entry相当于map中的value
type entry struct {
    p unsafe.Pointer
}
```

sync.Map 实现上有以下特点

1. 空间换时间。 通过冗余的两个数据结构(read、dirty),实现减少加锁对性能的影响。
2. 使用只读数据(read)，避免读写冲突。
3. 动态调整，miss次数多了之后，将dirty数据提升为read。
4. double-checking。
5. 延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。
6. 优先从read读取、更新、删除，因为对read的读取不需要锁。

最后我们用 `sync.Map`实现一下并发读写。

```golang
package main

import (
	"fmt"
	"sync"
)

var m sync.Map
var wg sync.WaitGroup

func Read() {
	for i:=0; i < 100000; i++{
		m.Store(1, 15)
	}
	fmt.Println("read done")
	wg.Done()
}

func Write() {
	for i:=0; i < 100000; i++{
		m.Load(1)
	}
	fmt.Println("write done")
	wg.Done()
}


func main() {
	wg.Add(2)
	m = sync.Map{}
	m.Store(1, 5)
	go Read()
	go Write()
	wg.Wait()
}
// 输出
// write done
// read done
```