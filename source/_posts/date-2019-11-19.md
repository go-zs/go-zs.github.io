---
title: golang系列(8)——time.Time分析
date: 2019-11-19 10:21:01
tags:
---

最近帮解服务上的bug，发现小兄弟在golang里用`int`用来表示时间, 思考了一下，用`int`表示时间戳似乎也没什么毛病。。但是，如果这样，golang又为何提供`time.Time`类型？

<!-- more -->

## 源码解读
1. `time.Time`定义

```golang
type Time struct {
	wall uint64   //  表示从公元1年1月1日00:00:00UTC到要表示的整数秒数
	ext  int64    //  表示的纳秒数
	loc *Location  // 时区，用于处理偏移
}
```

2. `time.Now()`

time.Now()默认使用本地时间, time.Local即本地时区, 取决于运行的系统环境设置, 优先取`TZ`这个环境变量, 然后取`/etc/localtime`, 如果这些都取不到就用`UTC`时间.

```golang
// Now returns the current local time.
func Now() Time {
	sec, nsec, mono := now()
	mono -= startNano
	sec += unixToInternal - minWall
	if uint64(sec)>>33 != 0 {
		return Time{uint64(nsec), sec + minWall, Local}
	}
	return Time{hasMonotonic | uint64(sec)<<nsecShift | uint64(nsec), mono, Local}
}
```

`unixToInternal`计算算法非常简洁
```golang
secondsPerDay    = 24 * secondsPerHour 
// UNIX系统认为1970年1月1日0点时间纪元，需要计算1969年之前的总秒数
unixToInternal int64 = (1969*365 + 1969/4 - 1969/100 + 1969/400) * secondsPerDay 
```

3. 时区`time.Location`定义
```golang
// A Location maps time instants to the zone in use at that time.
// Typically, the Location represents the collection of time offsets
// in use in a geographical area, such as CEST and CET for central Europe.
type Location struct {
	name string
	zone []zone
	tx   []zoneTrans

	// to lookup.
	cacheStart int64
	cacheEnd   int64
    cacheZone  *zone
}
// A zone represents a single time zone such as CEST or CET.
type zone struct {
	name   string // abbreviated name, "CET"
	offset int    // seconds east of UTC
	isDST  bool   // is this zone Daylight Savings Time?
}

// A zoneTrans represents a single time zone transition.
type zoneTrans struct {
	when         int64 // transition time, in seconds since 1970 GMT
	index        uint8 // the index of the zone that goes into effect at that time
	isstd, isutc bool  // ignored - no idea what these mean
}
```

4. `time.Parse` 实现

```golang
const (
	_                        = iota
	stdLongMonth             = iota + stdNeedDate  // "January"
	stdMonth                                       // "Jan"
	stdNumMonth                                    // "1"
	stdZeroMonth                                   // "01"
	stdLongWeekDay                                 // "Monday"
	stdWeekDay                                     // "Mon"
	stdDay                                         // "2"
	stdUnderDay                                    // "_2"
	stdZeroDay                                     // "02"
	stdUnderYearDay                                // "__2"
	stdZeroYearDay                                 // "002"
	stdHour                  = iota + stdNeedClock // "15"
	stdHour12                                      // "3"
	stdZeroHour12                                  // "03"
	stdMinute                                      // "4"
	stdZeroMinute                                  // "04"
	stdSecond                                      // "5"
	stdZeroSecond                                  // "05"
	stdLongYear              = iota + stdNeedDate  // "2006"
	stdYear                                        // "06"
    
    ...
)

// AppendFormat is like Format but appends the textual
// representation to b and returns the extended buffer.
func (t Time) AppendFormat(b []byte, layout string) []byte {
        ...

		switch std & stdMask {
		case stdYear:
			y := year
			if y < 0 {
				y = -y
			}
			b = appendInt(b, y%100, 2)
		case stdLongYear:
			b = appendInt(b, year, 4)
		case stdMonth:
			b = append(b, month.String()[:3]...)
		case stdLongMonth:
			m := month.String()
			b = append(b, m...)
		case stdNumMonth:
            b = appendInt(b, int(month), 0)
    
    ...
}
```

5. `time.Time`JSON序列化


```golang
RFC3339     = "2006-01-02T15:04:05Z07:00"
RFC3339Nano = "2006-01-02T15:04:05.999999999Z07:00"

// MarshalJSON implements the json.Marshaler interface.
// The time is a quoted string in RFC 3339 format, with sub-second precision added if present.
func (t Time) MarshalJSON() ([]byte, error) {
	if y := t.Year(); y < 0 || y >= 10000 {
		// RFC 3339 is clear that years are 4 digits exactly.
		// See golang.org/issue/4556#c15 for more discussion.
		return nil, errors.New("Time.MarshalJSON: year outside of range [0,9999]")
	}

	b := make([]byte, 0, len(RFC3339Nano)+2)
	b = append(b, '"')
	b = t.AppendFormat(b, RFC3339Nano)
	b = append(b, '"')
	return b, nil
}

// UnmarshalJSON implements the json.Unmarshaler interface.
// The time is expected to be a quoted string in RFC 3339 format.
func (t *Time) UnmarshalJSON(data []byte) error {
	// Ignore null, like in the main JSON package.
	if string(data) == "null" {
		return nil
	}
	// Fractional seconds are handled implicitly by Parse.
	var err error
	*t, err = Parse(`"`+RFC3339+`"`, string(data))
	return err
}
```

6. 时区计算

```golang
package main

import (
	"fmt"
	"time"
)

func main() {
	los, _ := time.LoadLocation("America/Los_Angeles")
	timeFormat := "2006-01-02 15:04:05"
	time1 := time.Unix(1578796676, 517932)
	time2, _ := time.ParseInLocation(timeFormat, "2020-01-11  18:37:56", los) //洛杉矶时间
	fmt.Println(time1.In(los).Format(timeFormat))
	fmt.Println(time2.In(los).Format(timeFormat))
	chinaLocal, _ := time.LoadLocation("Asia/Shanghai") // 指定时区
	fmt.Println(time2.In(chinaLocal).Format(timeFormat)) // 转换时区
}

// 输出
// 2020-01-11 18:37:56
// 2020-01-11 18:37:56
// 2020-01-12 10:37:56
```