---
title: golang系列(14)——定时器
date: 2019-12-27 18:18:18
updated: 2019-12-28 11:18:18
tags:
- golang
categories:
- golang
---

绝对时间一定不会是完全准确的，它对于一个运行中的分布式系统其实没有太多指导意义，但是由于相对时间的计算不依赖于外部的系统，所以它的计算可以做的比较准确。因此定时器对于一个程序非常重要，研究一下`Golang`里相对时间的定时器的实现原理也非常必要。


<!-- more -->

## Timer数据结构

`timer` 就是 `Golang` 定时器的内部表示，每一个 `timer` 其实都存储在堆中，`tb` 就是用于存储当前定时器的桶，而 `i` 是当前定时器在堆中的索引，我们可以通过这两个变量找到当前定时器在堆中的位置：

```golang
type timer struct {
	tb *timersBucket
	i  int

	when   int64
	period int64
	f      func(interface{}, uintptr)
	arg    interface{}
	seq    uintptr
}


```

`when` 表示当前定时器（Timer）被唤醒的时间，而 `period` 表示两次被唤醒的间隔，每当定时器被唤醒时都会调用 `f(args, now)` 函数并传入 `args` 和当前时间作为参数。然而这里的 `timer` 作为一个私有结构体其实只是定时器的运行时表示，`time` 包对外暴露的定时器使用了如下所示的结构体：

```golang
type Timer struct {
	C <-chan Time
	r runtimeTimer
}
```

`Timer` 定时器必须通过 `NewTimer` 或者 `AfterFunc` 函数进行创建，其中的 `runtimeTimer` 其实就是上面介绍的 `timer` 结构体，当定时器失效时，失效的时间就会被发送给当前定时器持有的 `Channel C`，订阅管道中消息的 `Goroutine` 就会收到当前定时器失效的时间。

在 `time` 包中，除了 `timer` 和 `Timer` 两个分别用于表示运行时定时器和对外暴露的 API 之外，timersBucket 这个用于存储定时器的结构体也非常重要，它会存储一个处理器上的全部定时器，不过如果当前机器的核数超过了 64 核，也就是机器上的处理器 P 的个数超过了 64 个，多个处理器上的定时器就可能存储在同一个桶中：

```golang
type timersBucket struct {
	lock         mutex
	gp           *g
	created      bool
	sleeping     bool
	rescheduling bool
	sleepUntil   int64
	waitnote     note
	t            []*timer  // 存储定时器，最小堆，最上面的元素就是最近需要唤醒的定时器
}
```

## 创建定时器

```golang
// 
func NewTimer(d Duration) *Timer {
	c := make(chan Time, 1)
	t := &Timer{
		C: c,
		r: runtimeTimer{
			when: when(d),
			f:    sendTime,
			arg:  c,
		},
	}
	startTimer(&t.r)
	return t
}

// 在定时器到期时调用传入的func
func AfterFunc(d Duration, f func()) *Timer {
	t := &Timer{
		r: runtimeTimer{
			when: when(d),
			f:    goFunc,
			arg:  f,
		},
	}
	startTimer(&t.r)
	return t
}

// startTimer 基本上就是创建定时器的入口了，所有定时器的创建和重启基本上都需要调用该函数：
func startTimer(t *timer) {
	addtimer(t)
}

func addtimer(t *timer) {
	tb := t.assignBucket()
	tb.addtimerLocked(t)
}

```


## 休眠

```golang
func timeSleep(ns int64) {
	if ns <= 0 {
		return
	}

	gp := getg()
	t := gp.timer
	if t == nil {
		t = new(timer)
		gp.timer = t
	}
	*t = timer{}
	t.when = nanotime() + ns
	t.f = goroutineReady
	t.arg = gp
	tb := t.assignBucket()
	lock(&tb.lock)
	if !tb.addtimerLocked(t) {
		unlock(&tb.lock)
		badTimer()
	}
	goparkunlock(&tb.lock, waitReasonSleep, traceEvGoSleep, 2)
}


// timeSleep 会创建一个新的 timer 结构体，在初始化的过程中我们会传入当前 Goroutine 应该被唤醒的时间以及唤醒时需要调用的函数 goroutineReady，
// 随后会调用 goparkunlock 将当前 Goroutine 陷入休眠状态，当定时器到期时也会调用 goroutineReady 方法唤醒当前的 Goroutine：
func goroutineReady(arg interface{}, seq uintptr) {
	goready(arg.(*g), 0)
}
```


## Ticker

除了只用于一次的定时器（Timer）之外，Go 语言的 time 包中还提供了用于多次通知的 Ticker 计时器，计时器中包含了一个用于接受通知的 Channel 和一个定时器，这两个字段共同组成了用于连续多次触发事件的计时器：

```golang
type Ticker struct {
	C <-chan Time // The channel on which the ticks are delivered.
	r runtimeTimer
}
```

创建一个计时器

```golang
func NewTicker(d Duration) *Ticker {
	if d <= 0 {
		panic(errors.New("non-positive interval for NewTicker"))
	}
	c := make(chan Time, 1)
	t := &Ticker{
		C: c,
		r: runtimeTimer{
			when:   when(d),
			period: int64(d),
			f:      sendTime,
			arg:    c,
		},
	}
	startTimer(&t.r)
	return t
}

func Tick(d Duration) <-chan Time {
	if d <= 0 {
		return nil
	}
	return NewTicker(d).C
}
```

需要注意的是每一个 NewTicker 方法开启的计时器都需要在不需要使用时调用 Stop 进行关闭，如果不显示调用 Stop 方法，创建的计时器就没有办法被垃圾回收，而通过 Tick 创建的计时器由于只对外提供了 Channel，所以是一定没有办法关闭的，我们一定要谨慎使用这一接口创建计时器。