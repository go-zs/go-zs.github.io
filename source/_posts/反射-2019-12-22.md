---
title: golang系列(13)——反射
date: 2019-12-22 17:58:54
updated: 2019-12-22 17:58:54
tags:
---

反射是 `Go` 语言比较重要的一个特性之一，虽然在大多数的应用和服务中并不常见，但是很多框架都依赖 `Go` 语言的反射机制实现一些动态的功能。作为一门静态语言，`Golang` 在设计上都非常简洁，所以在语法上其实并没有较强的表达能力，但是 `Go` 语言为我们提供的 `reflect` 包提供的动态特性却能够弥补它在语法上的一些劣势。

<!-- more -->

## Type

类型 `Type` 是 `Golang` 反射包中定义的一个接口，我们可以使用 `TypeOf` 函数获取任意值的变量的的类型，我们能从这个接口中看到非常多有趣的方法，`MethodByName` 可以获取当前类型对应方法的引用、`Implements` 可以判断当前类型是否实现了某个接口：

```golang
type Type interface {
        Align() int
        FieldAlign() int
        Method(int) Method
        MethodByName(string) (Method, bool)
        NumMethod() int
        Name() string
        PkgPath() string
        Size() uintptr
        String() string
        Kind() Kind
        Implements(u Type) bool
        ...
}
```

## Value

反射包中 `Value` 的类型却与 `Type` 不同，`Type` 是一个接口类型，但是 `Value` 在 `reflect` 包中的定义是一个结构体，这个结构体没有任何对外暴露的成员变量，但是却提供了很多方法让我们获取或者写入 Value 结构体中存储的数据

```golang
type Value struct {
        // contains filtered or unexported fields
}

func (v Value) Addr() Value
func (v Value) Bool() bool
func (v Value) Bytes() []byte
func (v Value) Float() float64
// ...
```

## 反射法则

运行时反射是程序在运行期间检查其自身结构的一种方式，它是 `元编程` 的一种，但是它带来的灵活性也是一把双刃剑，过量的使用反射会使我们的程序逻辑变得难以理解并且运行缓慢，我们在这一节中就会介绍 `Go` 语言反射的三大法则，这能够帮助我们更好地理解反射的作用。

1. 从接口值可反射出反射对象；
2. 从反射对象可反射出接口值；
3. 要修改反射对象，其值必须可设置；


### 获得对象类型
```golang
package main

import (
	"fmt"
	"reflect"
)

func main() {
	author := "draven"
	fmt.Println("TypeOf author:", reflect.TypeOf(author))
	fmt.Println("ValueOf author:", reflect.ValueOf(author))
}
// 输出
// TypeOf author: string
// ValueOf author: draven

```

### 获得对象值
```golang
v := reflect.ValueOf(1)
v.Interface{}.(int)
```

### 修改值
`Go` 语言反射的最后一条法则是与值是否可以被更改相关的，如果我们想要更新一个 `reflect.Value`，那么它持有的值一定是可以被更新的。

```golang
func main() {
	i := 1
	v := reflect.ValueOf(i)
	v.SetInt(10)
	fmt.Println(i)
}
// 输出
// panic: reflect: reflect.flag.mustBeAssignable using unaddressable value
```

想要修改原有的变量我们只能通过如下所示的方法，首先通过 `reflect.ValueOf` 获取变量指针，然后通过 `Elem` 方法获取指针指向的变量并调用 `SetInt` 方法更新变量的值：

```golang
func main() {
	i := 1
	v := reflect.ValueOf(&i)
	v.Elem().SetInt(10)
	fmt.Println(i)
}
// output
// 10
```

## 反射原理

### 类型和值

`Golang` 的 `interface{}` 类型在语言内部都是通过 `emptyInterface` 这个结体来表示的，其中包含一个 `rtype` 字段用于表示变量的类型以及一个 `word` 字段指向内部封装的数据：

```golang
type emptyInterface struct {
	typ  *rtype
	word unsafe.Pointer
}
```

用于获取变量类型的 `TypeOf` 函数就是将传入的 `i` 变量强制转换成 `emptyInterface` 类型并获取其中存储的类型信息 `rtype`

```golang
func TypeOf(i interface{}) Type {
	eface := *(*emptyInterface)(unsafe.Pointer(&i))
	return toType(eface.typ)
}

func toType(t *rtype) Type {
	if t == nil {
		return nil
	}
	return t
}
```

`rtype` 就是一个实现了 `Type` 接口的接口体，我们能在 `reflect` 包中找到如下所示的 `Name` 方法帮助我们获取当前类型的名称等信息：

```golang
func (t *rtype) String() string {
	s := t.nameOff(t.str).name()
	if t.tflag&tflagExtraStar != 0 {
		return s[1:]
	}
	return s
}
```

`TypeOf` 函数的实现原理其实并不复杂，它只是将一个 `interface{}` 变量转换成了内部的 `emptyInterface` 表示，然后从中获取相应的类型信息。

用于获取接口值 `Value` 的函数 `ValueOf` 实现也非常简单，在该函数中我们先调用了 `escapes` 函数保证当前值逃逸到堆上，然后通过 `unpackEface` 方法从接口中获取 `Value` 结构体：

```golang
func ValueOf(i interface{}) Value {
	if i == nil {
		return Value{}
	}

	escapes(i)

	return unpackEface(i)
}

func unpackEface(i interface{}) Value {
	e := (*emptyInterface)(unsafe.Pointer(&i))
	t := e.typ
	if t == nil {
		return Value{}
	}
	f := flag(t.Kind())
	if ifaceIndir(t) {
		f |= flagIndir
	}
	return Value{t, e.word, f}
}
```

`unpackEface` 函数会将传入的接口 `interface{}` 转换成 `emptyInterface` 结构体然后将其中表示接口值类型、指针以及值的类型包装成 `Value` 结构体并返回。