---
title: golang系列(12)——Context上下文
date: 2019-12-19 15:25:58
updated: 2019-12-19 15:25:58
tags:
- golang
categories:
- golang
---

context应该是golang中最有意思的设计了，它是实现golang并发编程的核心，了解它的使用才能真正的控制goroutine的并发。

<!-- more -->


Go中`HTTP`或`RPC` 请求的都会启动新的 `goroutine` 访问服务器、数据库和 RPC 服务，我们也可能会创建多个 Goroutine 来处理一次请求，而 `context` 的主要作用就是在不同的 `goroutine` 之间同步请求特定的数据、取消信号以及处理请求的`deadline`。

## Context数据结构

context本质上是一个context包的接口

```golang
type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() <-chan struct{}
	Err() error
	Value(key interface{}) interface{}
}
```


### emptyCtx

emptyCtx 实现了一个最简单的context接口，无论何时调用都会返回nil或者宿舍。


```golang
type emptyCtx int

func (*emptyCtx) Deadline() (deadline time.Time, ok bool) {
	return
}

func (*emptyCtx) Done() <-chan struct{} {
	return nil
}

func (*emptyCtx) Err() error {
	return nil
}

func (*emptyCtx) Value(key interface{}) interface{} {
	return nil
}
```

### Background and TODO
这两个都是emptyCtx的实例化

```golang
var (
	background = new(emptyCtx)
	todo       = new(emptyCtx)
)
func Background() Context {
	return background
}

func TODO() Context {
	return todo
}
```

### 取消信号

WithCancel 方法能够从 Context 中创建出一个新的子上下文，同时还会返回用于取消该上下文的函数，也就是 CancelFunc，我们直接从 WithCancel 函数的实现来看它到底做了什么：

```golang
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
	c := newCancelCtx(parent)
	propagateCancel(parent, &c)
	return &c, func() { c.cancel(true, Canceled) }
}
```
newCancelCtx 是包中的私有方法，它将传入的父上下文包到私有结构体 cancelCtx{Context: parent} 中，cancelCtx 就是当前函数最终会返回的结构体类型，我们在详细了解它是如何实现接口之前，先来了解一下用于传递取消信号的 propagateCancel 函数：

```golang
func propagateCancel(parent Context, child canceler) {
	if parent.Done() == nil {
		return // parent is never canceled
	}
	if p, ok := parentCancelCtx(parent); ok {
		p.mu.Lock()
		if p.err != nil {
			child.cancel(false, p.err)
		} else {
			if p.children == nil {
				p.children = make(map[canceler]struct{})
			}
			p.children[child] = struct{}{}
		}
		p.mu.Unlock()
	} else {
		go func() {
			select {
			case <-parent.Done():
				child.cancel(false, parent.Err())
			case <-child.Done():
			}
		}()
	}
}
```

cancelCtx 实现的几个接口方法其实没有太多值得介绍的地方，该结构体最重要的方法其实是 cancel 方法，这个方法会关闭上下文的管道并向所有的子上下文发送取消信号：

```golang
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
	c.mu.Lock()
	if c.err != nil {
		c.mu.Unlock()
		return
	}
	c.err = err
	if c.done == nil {
		c.done = closedchan
	} else {
		close(c.done)
	}
	for child := range c.children {
		child.cancel(false, err)
	}
	c.children = nil
	c.mu.Unlock()

	if removeFromParent {
		removeChild(c.Context, c)
	}
}
```

### 截止时间


除了 WithCancel 之外，context 包中的另外两个函数 WithDeadline 和 WithTimeout 也都能创建可以被取消的上下文，WithTimeout 只是 context 包为我们提供的便利方法，能让我们更方便地创建 timerCtx：

```golang
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
	return WithDeadline(parent, time.Now().Add(timeout))
}

func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {
	if cur, ok := parent.Deadline(); ok && cur.Before(d) {
		return WithCancel(parent)
	}
	c := &timerCtx{
		cancelCtx: newCancelCtx(parent),
		deadline:  d,
	}
	propagateCancel(parent, c)
	dur := time.Until(d)
	if dur <= 0 {
		c.cancel(true, DeadlineExceeded) // deadline has already passed
		return c, func() { c.cancel(false, Canceled) }
	}
	c.mu.Lock()
	defer c.mu.Unlock()
	if c.err == nil {
		c.timer = time.AfterFunc(dur, func() {
			c.cancel(true, DeadlineExceeded)
		})
	}
	return c, func() { c.cancel(true, Canceled) }
}
```


### 传值方法

在最后我们需要了解一下如何使用上下文传值，context 包中的 WithValue 函数能从父上下文中创建一个子上下文，传值的子上下文使用私有结构体 valueCtx 类型：

```golang
func WithValue(parent Context, key, val interface{}) Context {
	if key == nil {
		panic("nil key")
	}
	if !reflectlite.TypeOf(key).Comparable() {
		panic("key is not comparable")
	}
	return &valueCtx{parent, key, val}
}
```

valueCtx 函数会将除了 Value 之外的 Err、Deadline 等方法代理到父上下文中，只会处理 Value 方法的调用，然而每一个 valueCtx 内部也并没有存储一个键值对的哈希，而是只包含一个键值对：

```golang

type valueCtx struct {
	Context
	key, val interface{}
}

func (c *valueCtx) Value(key interface{}) interface{} {
	if c.key == key {
		return c.val
	}
	return c.Context.Value(key)
}
```

当然context传值功能非常少用，一般用于分布式追踪请求id。

常见的web框架，比如`gin`中的`Context`也是实现了`context`接口。

```golang
// Context is the most important part of gin. It allows us to pass variables between middleware,
// manage the flow, validate the JSON of a request and render a JSON response for example.
type Context struct {
	writermem responseWriter
	Request   *http.Request
	Writer    ResponseWriter

	Params   Params
	handlers HandlersChain
	index    int8

	engine *Engine

	// Keys is a key/value pair exclusively for the context of each request.
	Keys map[string]interface{}

	// Errors is a list of errors attached to all the handlers/middlewares who used this context.
	Errors errorMsgs

	// Accepted defines a list of manually accepted formats for content negotiation.
	Accepted []string
}
```
