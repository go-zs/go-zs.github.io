---
title: golang系列(11)——并发
date: 2019-12-12 14:52:56
tags:
---

golang并发很简单，实现方式也很多样。不同的实现方式都有哪些特点呢。

<!-- more -->

## 最简单的实现

```golang

// 同步

func main() {
    fmt.Println("Hello World")
}

// 并发

func main() {
    go fmt.Println("Hello World")
}

```

这样实现很有可能`Hello World`并不会打印出来，因为main函数会退出。



## 防止main函数退出

```golang
// 撞大运
func main() {
    go fmt.Println("Hello World")
    time.Sleep(time.Second)
}

// 死循环, 非常糟糕，for循环会独占线程
func main() {
    go fmt.Println("Hello World")
    for {}
}

// 利用select阻塞
func main() {
    go fmt.Println("Hello World")
    select{} // 阻塞, 不占用CPU
}

// 利用channel阻塞
func main() {
    go fmt.Println("Hello World")
    <-make(chan int) // 阻塞, 不占用CPU
}

```

上面两种都会导致`fatal error: all goroutines are asleep - deadlock!`, 因为阻塞导致死锁异常。

```golang

func main() {
    go println("你好, 并发!") // 干活的

    go func() { <-make(chan int) } () // 滥竽充数的, Goroutine 泄露
    go func() { for{} } () // 浪费资源的, 但不是 Goroutine 泄露
    go func() {} () // 滥竽充数的, 但不是 Goroutine 泄露

    time.Sleep(time.Second)
    println("Done")
}
```

* 完美的并发需要做好 goroutine 的善后工作
```golang

func main() {
    done := make(chan bool)
    go func() {
        println("Hello World")
        done <- true
    }()

    <-done
}
// main 函数阻塞, 直到 done 管道有数据
// 当 done 管道有数据时, 后台 Goroutine 必然已经完成了打印工作
// Goroutine 何时退出并不关心, 重点是工作已经完成了
```

## 闭包陷阱
函数执行时，`i`的值并不确定

```golang
package main

import "sync"

var wg sync.WaitGroup

func main() {
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			println(i)
			wg.Done()
		}()
	}
	wg.Wait()
}
// 输出，多次运行，也可能打印出3，4等其它结果
// 5
// 5
// 5
// 5
// 5
```


## 同一个Goroutine内: 满足顺序一致性内存模型

```golang
var msg string
var done bool = false

func main() {
    msg = "hello, world"
    done = true

    for {
        if done {
            println(msg)
            break
        }
        println("retry...")
    }
}
```

## 不同Goroutine之间: 不满足顺序一致性!

```golang
var msg string
var done bool = false

func main() {
    runtime.GOMAXPROCS(2)

    go func() {
        msg = "hello, world"
        done = true
    }()

    for {
        if done {
            println(msg); break
        }
        println("retry...")
    }
}
// main线程可能无法看到后台线程对msg和done做的更新
// msg 的修改不是原子操作, main可能看到被修改一半的数据
// 多线程环境, 程序结果未知
```


## Goroutine特点

- 由go关键字启动, 是一种轻量级的线程
- 以一个很小的栈启动(可能是2KB/4KB), 可以启动很多
- Goroutine栈的大小会根据需要动态地伸缩, 不用担心栈溢出
- m个goroutine运行在n个操作系统线程上, n默认对应CPU核数
- runtime.GOMAXPROCS用于控制当前运行运行正常非阻塞Goroutine的系统线程数目
- 发生在用户态, 切换的代价要比系统线程低(切换时只需要保存必要的寄存器)
- Goroutine采用的是半抢占式的协作调度(在函数入口处插入协作代码)
- IO/sleep/runtime.Gosched 均会导致调度
- runtime 无法强制剥夺纯计算型 Goroutine 的运行
- Goroutine故意设计为没有ID

####  注意：Goroutine是一种资源，也有泄露的风险！

