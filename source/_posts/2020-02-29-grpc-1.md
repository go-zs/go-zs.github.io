---
title: grpc(1)--protobuf语法
date: 2020-02-29 17:31:09
tags:
- grpc
---

gRPC是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。
Protocol Buffer (简称Protobuf) 是Google出品的性能优异、跨语言、跨平台的序列化库。


<!-- more -->

## protobuf介绍

Protocol buffers 是一种语言中立，平台无关，可扩展的序列化数据的格式，可用于通信协议，数据存储等。

Protocol buffers 在序列化数据方面，它是灵活的，高效的。相比于 XML 来说，Protocol buffers 更加小巧，更加快速，更加简单。一旦定义了要处理的数据的数据结构之后，就可以利用 Protocol buffers 的代码生成工具生成相关的代码。甚至可以在无需重新部署程序的情况下更新数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。

Protocol buffers 很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。

## protobuf优点

* 足够简单
* 序列化后体积很小:消息大小只需要XML的1/10 ~ 1/3
* 解析速度快:解析速度比XML快20 ~ 100倍
* 多语言支持
* 更好的兼容性,Protobuf设计的一个原则就是要能够很好的支持向下或向上兼容

## 基本语法

官方建议新项目采用proto3，主要介绍一下proto3的语法

下面是一个`hello world`的例子

```proto
syntax = "proto3"; // 指定proto版本

package hello; // 指定默认包名

// 定义 Hello Service
service Hello {
    // 定义SayHello方法
    rpc SayHello (HelloRequest) returns (HelloResponse) {}
}

// 定义请求值 HelloRequest 
message HelloRequest {
    string name = 1;  // 变量类型 + 变量名 = 序号
}

// 定义返回值结构 HelloResponse
message HelloResponse {
    string message = 1;
}
```

## 基本类型

* 数字类型： double、float、int32、int64、uint32、uint64、sint32、sint64: 存储长度可变的浮点数、整数、无符号整数和有符号整数
* 存储固定大小的数字类型：fixed32、fixed64、sfixed32、sfixed64: 存储空间固定
* 布尔类型: bool
* 字符串: string
* bytes: 字节数组
* messageType: 消息类型
* enumType:枚举类型

```proto
enum EnumAllowingAlias {
  // allow_alias 允许字段编号重复
  option allow_alias = true;
  UNKNOWN = 0;
  STARTED = 1;
  RUNNING = 1;
}
```

## import其它proto文件

```proto
import  "other.proto";
```

## package

`package`定义包名，同名的`message`可以通过不同的`package`名进行区分。

```proto
package abc.hello;
```

## oneof

`oneof`可以实现最多允许一组字段中一个字段出现，它是支持设置零值。由于proto3无法判断字段是否设置值（未设置值的情况下会默认零值），可以通过`oneof`来判断字段是否设置值。


```proto
syntax = "proto3";
package oneof;
message OneofMessage {
    oneof oneof_msg {
      string name = 4;
      int64 value = 9;
    }
  }
```

## 数组

```proto
message Student {
  required int32 age = 1;
  required string name = 2;
}

message Class {
  repeated Student student = 1;
}
```

## Map

```proto
map<int64,string> values = 1;
```


## Reserved

Reserved可以用来指明此message不使用某些字段，也就是忽略这些字段。

可以通过字段编号范围或者字段名称指定保留的字段

```
reserved 1, 4 to 6;
reserved "field1", "field2";
```


## any

any字段是protobuf内置的类型，通用类型, any字段是以bytes呈现序列化的消息

```proto
import "google/protobuf/any.proto";
message ErrorStatus {
  string message = 1;
  repeated google.protobuf.Any details = 2;
}
```

## 更新消息类型

有时候你不得不修改正在使用的proto文件，比如为类型增加一个字段，protobuf支持这种修改而不影响已有的服务，不过你需要遵循一定的规则：

* 不要改变已有字段的字段编号
* 当你增加一个新的字段的时候，老系统序列化后的数据依然可以被你的新的格式所解析，只不过你需要处理新加字段的缺省值。 老系统也能解析你信息的值，新加字段只不过被丢弃了
* 字段也可以被移除，但是建议你Reserved这个字段，避免将来会使用这个字段
* int32, uint32, int64, uint64 和 bool类型都是兼容的
* sint32 和 sint64兼容，但是不和其它整数类型兼容
* string 和 bytes兼容，如果 bytes 是合法的UTF-8 bytes的话
* 嵌入类型和bytes兼容，如果bytes包含一个消息的编码版本的话
* fixed32和sfixed32, fixed64和sfixed64
* enum和int32, uint32, int64, uint64格式兼容
* 把单一一个值改变成一个新的oneof类型的一个成员是安全和二进制兼容的。把一组字段变成一个新的oneof字段也是安全的，如果你确保这一组字段最多只会设置一个。把一个字段移动到一个已存在的oneof字段是不安全的