---
title: golang系列(16)——channel
date: 2020-01-18 13:26:06
tags:
---

`channel`是`golang`非常核心的数据结构，总结一下`channel`的用法。

<!-- more -->


## channel类型

```golang
// 带缓存的channel
c := make(chan int, 10)

// 不带缓存的channel
c := make(chan int)

// 只读channel
c := make(chan<- int)

// 只写channel
c := make(<-chan int)

```

最开始一直没想明白，只读channel怎么用，因为它只读，直接写数据会`panic`，`channel`里是可以直接转换类型，也可以通过函数转换`channel`类型

直接转换
```
package main

import "fmt"

func main() {
	ch1 := make(chan int)
	ch2 := (<-chan int)(ch1) // ch2就是一个单向的读取channel
	ch3 := chan<- int(ch1) // ch3 是一个单向的写入channel
	fmt.Println(ch1, ch2, ch3)
}

// output
// 0xc0000b0000 0xc0000b0000 0xc0000b0000
```

通过函数转换
```golang
package main

import (
	"fmt"
)

func send(c chan int ) <-chan int {
	c <- 1
	return c // 转换为只读
}

func main() {
	a := make(chan int, 1
	b := send(a)  // b为 <-chan int
	select {
	case c := <- b:
		fmt.Println("c = ", c)
	}
}
// output
// c =  1
```
## Close

判断一个channel是否关闭

```golang
package main

import "fmt"

func main() {
	c := make(chan int)
	close(c)
	if v, ok := <- c; ok {
		fmt.Println(v)
	} else {
		fmt.Println("channel has been closed")
	}
}
// output
// channel has been closed
```

关闭或写入`closed`的`channel`, 都会引发`panic`

```golang
// close closed channel
package main

func main() {
	c := make(chan int)
	close(c)
	close(c)
}

// output
// panic: close of closed channel

// 写入closed channel
package main

func main() {
	c := make(chan int)
	close(c)
	c <- 1
}
// output
// panic: send on closed channel
```

读取`closed`的`channel`, 会一直读到零值

```
package main

import "fmt"

func main() {
	c := make(chan int)
	close(c)
	for {
		v := <- c
		fmt.Println(v)
	}
}

// output
// 0
// 0
// 0
// ...
```

## Range
`for-range`语法可以用到通道上。`Range`循环会一直接收channel里面的数据，直到`channel`关闭。不同于`array/slice/map`上的`for-range`，`channel`的`for-range`只允许有一个变量。

注意`for-range`对应的channel不能是只写channe

```golang
package main

import "fmt"

func main() {
	c := make(chan int, 5)
	for i:=0;i<5;i++ {
		c<- i
	}
    close(c)
    // range 会读空channel
    // 如果 channel未close，会一直堵塞通道
	for v := range c {
		fmt.Println(v) 
	}
}

// output
// 0
// 1
// 2
// 3
// 4
```

## select

### 多个通道

`select`多个通道都满足时，会随机选择一个执行

```golang
package main

import "fmt"

func main() {
	a := make(chan string, 1)
	b := make(chan string, 1)
	a <- "a"
	b <- "b"
	var v string
	select {
	case v = <- a:
		fmt.Println(v)
	case v = <- b:
		fmt.Println(v)
	}
}

// output
// 多次几次 随机输出 "a"  or "b"
```

### timeout channel

```golang
package main

import (
	"fmt"
	"time"
)

func main() {
	c := make(chan int)
	select {
	case <-time.NewTimer(time.Second).C:
		fmt.Println("time out")
	case <-c:
		fmt.Println("get value")
	}
}

// output
// time out
```